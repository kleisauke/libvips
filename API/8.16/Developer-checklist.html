<!DOCTYPE html>
<html lang="en-us">
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="UTF-8">
    <title>libvips</title>
    <meta name="description" content="A fast image processing library with low memory needs.">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Cabin:400,700" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/assets/css/style.css">
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name"><a href="/">libvips</a></h1>
      <h2 class="project-tagline">A fast image processing library with low memory needs.</h2>

      <a href="https://github.com/libvips/libvips/releases" class="btn">Download</a>
      <a href="/install.html" class="btn">Install</a>
      <a href="/API/current" class="btn">Documentation</a>
      <a href="https://github.com/libvips/libvips/issues" class="btn">Issues</a>
      <a href="https://github.com/libvips/libvips/wiki" class="btn">Wiki</a>
      <a href="https://github.com/libvips" class="btn">libvips projects</a>
      <a href="https://github.com/libvips/libvips" class="btn">libvips on GitHub</a>

    </section>

    <section class="main-content">
<table class="navigation" id="top" width="100%" summary="Navigation header" cellpadding="2" cellspacing="5"><tr valign="middle">
<td width="100%" align="left" class="shortcuts"></td>
<td><a accesskey="h" href="index.html"><img src="home.png" width="16" height="16" border="0" alt="Home"></a></td>
<td><a accesskey="u" href="ch01.html"><img src="up.png" width="16" height="16" border="0" alt="Up"></a></td>
<td><a accesskey="p" href="libvips-from-C++.html"><img src="left.png" width="16" height="16" border="0" alt="Prev"></a></td>
<td><a accesskey="n" href="binding.html"><img src="right.png" width="16" height="16" border="0" alt="Next"></a></td>
</tr></table>
<div class="refentry">
<a name="Developer-checklist"></a><div class="titlepage"></div>
<p>
  
</p>
<p>
  </p>
<div class="refnamediv"><table width="100%"><tr>
<td valign="top">
<h2>Dev checklist</h2>
<p>Dev checklist — Checklist for libvips users</p>
</td>
<td class="gallery_image" valign="top" align="right"></td>
</tr></table></div>
<p>
</p>
<p>
  libvips is a slightly unusual library and you may need to take some of its stranger features into account when you design software that uses it.
</p>
<div class="refsect3">
<a name="if-you-can-use-thumbnail-not-resize"></a><h4>If you can, use <code class="literal">thumbnail</code>, not <code class="literal">resize</code>
</h4>
<p>
    The <code class="literal">thumbnail</code> operation combines load and resize into one step. This lets it take advantage of format library features, such as shrink on load, and can lead to a large improvement in speed and a large drop in memory use.
  </p>
<p>
    For example, with this JPEG image:
  </p>
<pre class="programlisting">
$ vipsheader nina.jpg
nina.jpg: 6048x4032 uchar, 3 bands, srgb, jpegload
</pre>
<p>
    I see:
  </p>
<pre class="programlisting">
$ /usr/bin/time -f %M:%e vips resize nina.jpg x.jpg 0.1
123648:0.23
</pre>
<p>
    124 MB of RAM and 0.23s to shink by a factor of 10. With <code class="literal">thumbnail</code> it’s:
  </p>
<pre class="programlisting">
$ /usr/bin/time -f %M:%e vips thumbnail nina.jpg x.jpg 605
68864:0.08
</pre>
<p>
    Now it’s 68 MB of memory and 0.08s – half the memory use, and 3x faster. In fact the improvement is better than that, since the <code class="literal">vips</code> command takes a while to start and needs a fair amount of memory:
  </p>
<pre class="programlisting">
$ /usr/bin/time -f %M:%e vips &gt; /dev/null
31232:0.02
</pre>
<p>
    31 MB and 0.02s, so <code class="literal">thumbnail</code> is really 2.5x less memory and 4x faster.
  </p>
<p>
    You can see much larger improvements with other formats, and quality will often be better as well, since <code class="literal">thumbnail</code> will automatically premultiply and can render vector images directly at the correct size.
  </p>
</div>
<div class="refsect3">
<a name="dont-use-thumbnail_image"></a><h4>Don’t use <code class="literal">thumbnail_image</code>
</h4>
<p>
    It’s just there for emergencies. It can’t do any of the rendering tricks, so it’s no faster than <code class="literal">resize</code>. Use <code class="literal">thumbnail</code> if you can.
  </p>
</div>
<div class="refsect3">
<a name="use-sequential-mode-if-you-can"></a><h4>Use sequential mode if you can</h4>
<p>
    This is a hint you pass to <code class="literal">new_from_file</code> and friends that signals that you will only scan this image in the direction that the underlying load library supports. This can give a useful improvement in speed and reduction in memory use in many cases.
  </p>
<p>
    See the <span class="quote">“<span class="quote">How it opens files</span>”</span> chapter for background on this feature.
  </p>
</div>
<div class="refsect3">
<a name="use-longer-pipelines-if-you-can"></a><h4>Use longer pipelines if you can</h4>
<p>
    libvips is demand-driven, and uses partial images as intermediates. This means you can construct long pipelines of image processing operations, they won’t use much memory, and they’ll (usually) join efficiently.
  </p>
<p>
    libvips is horizontally threaded, meaning that threads run along the pipeline of operations you are evaluating, not up and down images. This means that libvips can (usually) parallelise longer pipelines more efficiently than short ones.
  </p>
<p>
    If you can, aim for long pipelines of processing operations.
  </p>
</div>
<div class="refsect3">
<a name="cache-commonly-reused-images"></a><h4>Cache commonly reused images</h4>
<p>
    If an image is reused repeatedly in one pipeline, it’ll be recomputed each time. You can sometimes get a big speedup by keeping images like this in memory rather than recalculating their pixels, see (for example), <code class="literal">copy_memory()</code> in pyvips.
  </p>
<p>
    This can raise memory use, of course.
  </p>
</div>
<div class="refsect3">
<a name="adjust-the-order-of-operations-in-pipelines"></a><h4>Adjust the order of operations in pipelines</h4>
<p>
    If you can, put large resizes right at the start (see <code class="literal">thumbnail</code> above), then area filters (sharpen, for example), and finally any point operations.
  </p>
</div>
<div class="refsect3">
<a name="only-enable-the-load-libraries-you-need"></a><h4>Only enable the load libraries you need</h4>
<p>
    libvips after version 8.13 has a system for enabling and disabling image load libraries at runtime, see:
  </p>
<p>
    https://www.libvips.org/2022/05/28/What’s-new-in-8.13.html
  </p>
<p>
    You can usually improve security and avoid memory spikes by only enabling the image formats you really need. If you are handling untrusted data, I would set the <code class="literal">VIPS_BLOCK_UNTRUSTED</code> env var and only use the loaders we have tested for security.
  </p>
<p>
    Older versions of libvips need compile-time configuration.
  </p>
</div>
<div class="refsect3">
<a name="sanity-check-images-before-processing"></a><h4>Sanity-check images before processing</h4>
<p>
    libvips image open is always fast and safe, as long as you have disabled load via imagemagick. This means you can open an image and sanity-check it before further processing.
  </p>
<p>
    There are two main checks that are very worthwhile:
  </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem"><p>
        Sanity check image dimensions to protect you from decompression bombs like those described at https://www.bamsoftware.com/hacks/deflate.html
      </p></li>
<li class="listitem">
<p>
        Check for interlaced (also called progressive) images.
      </p>
<p>
        These are the ones that appear in low detail first, then progressively sharpen as they are downloaded.
      </p>
<p>
        The downside is that you don’t get the final pixels until the whole image is in memory, which prevents any streaming processing and hugely increases memory use. For example:
      </p>
</li>
</ol></div>
<pre class="programlisting">
$ /usr/bin/time -f %M:%e vipsthumbnail big-progressive.jpg
3732224:4.23
$ vips copy big-progressive.jpg x.jpg
$ /usr/bin/time -f %M:%e vipsthumbnail x.jpg
72448:0.26
</pre>
<p>
    So this progressive jpeg takes 4gb of memory and 4.3s to thumbnail, but exactly the same image as a regular jpeg takes 72mb and 0.26s.
  </p>
<p>
    I would detect these horrors before processing by looking for the <code class="literal">interlaced</code> metadata item and either ban them, or if your users insist on uploading in this terrible format, push them to a separate low-priority queue on a special container. Keep them away from your main image path.
  </p>
</div>
<div class="refsect3">
<a name="linux-memory-allocator"></a><h4>Linux memory allocator</h4>
<p>
    The default memory allocator on most glibc-based Linux systems (e.g. Debian, Red Hat) is unsuitable for long-running, multi-threaded processes that involve lots of small memory allocations.
  </p>
<p>
    To help avoid fragmentation and improve performance on these systems, the use of an alternative memory allocator such as jemalloc is recommended.
  </p>
<p>
    Those using musl-based Linux (e.g. Alpine) and non-Linux systems are unaffected.
  </p>
</div>
<div class="refsect3">
<a name="disable-the-libvips-operation-cache-if-you-dont-need-it"></a><h4>Disable the libvips operation cache if you don’t need it</h4>
<p>
    The libvips operation cache is not useful for image proxies (i.e. processing many different images). Consider disabling this with <code class="literal">vips_cache_set_max(0);</code>.
  </p>
</div>
</div>
<div class="footer">
<hr>Generated by GTK-Doc V1.34.0</div>
</section>

    <script type="text/javascript">
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-48550036-2', 'auto');
      ga('send', 'pageview');
    </script>
  </body>
</html>
